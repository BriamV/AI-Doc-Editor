/**
 * FeedbackTemplateService.cjs - Issue Template Generation Service
 * Single Responsibility: Only generate templates for issue reporting
 * Extracted from FeedbackManager.cjs for better modularity (RNF-001: â‰¤212 lines)
 */

const TemplateManager = require('./TemplateManager.cjs');

class FeedbackTemplateService {
  constructor(config, logger) {
    this.config = config;
    this.logger = logger || { info: () => {}, warn: () => {}, error: () => {} };
    this.templateManager = new TemplateManager(config, logger);
  }
  
  /**
   * Generate complete issue report template
   */
  async generateIssueReport(context = {}) {
    try {
      this.logger.info('FeedbackTemplateService: Generating issue template...');
      return await this.templateManager.generateIssueReport(context);
    } catch (error) {
      this.logger.error(`FeedbackTemplateService: Failed to generate template: ${error.message}`);
      return this._generateFallbackTemplate(context);
    }
  }
  
  /**
   * Generate minimal template for URL length constraints
   */
  generateMinimalTemplate(context) {
    return `# QA System Issue

**Tool:** ${context.failedTool || 'unknown'}
**Error:** ${context.errorMessage || 'No error message'}
**Command:** \`${context.command || 'unknown'}\`

*Auto-generated by QA System v${context.qaVersion || '0.1.0'}*`;
  }
  
  /**
   * Generate appropriate issue title
   */
  generateIssueTitle(context) {
    const tool = context.failedTool || 'QA System';
    const dimension = context.toolDimension || 'general';
    const mode = context.mode || 'automatic';
    
    if (context.errorMessage) {
      return `QA System Issue: ${tool} (${dimension}) - ${mode} mode`;
    }
    
    return `QA System Feedback: ${tool} - ${dimension}`;
  }
  
  /**
   * Generate appropriate GitHub issue labels
   */
  generateIssueLabels(context) {
    const labels = ['qa-system', 'automated-report'];
    
    // Add labels based on context
    if (context.failedTool) {
      labels.push('bug');
      labels.push(`tool:${context.failedTool.toLowerCase()}`);
    }
    
    if (context.toolDimension) {
      labels.push(`dimension:${context.toolDimension.toLowerCase()}`);
    }
    
    if (context.mode) {
      labels.push(`mode:${context.mode.toLowerCase()}`);
    }
    
    if (context.platform) {
      labels.push(`platform:${context.platform.toLowerCase()}`);
    }
    
    // Add priority based on error type
    if (context.errorType) {
      switch (context.errorType.toLowerCase()) {
        case 'critical':
        case 'fatal':
          labels.push('priority:high');
          break;
        case 'warning':
          labels.push('priority:medium');
          break;
        default:
          labels.push('priority:low');
          break;
      }
    }
    
    return labels;
  }
  
  /**
   * Generate issue summary for quick reference
   */
  generateIssueSummary(reportId, context) {
    const timestamp = new Date().toISOString();
    const title = this.generateIssueTitle(context);
    const labels = this.generateIssueLabels(context);
    
    return {
      reportId,
      timestamp,
      title,
      labels,
      tool: context.failedTool || 'unknown',
      dimension: context.toolDimension || 'general',
      mode: context.mode || 'automatic',
      platform: context.platform || process.platform,
      summary: this._extractSummaryFromContext(context)
    };
  }
  
  /**
   * Generate progressive templates with different levels of detail
   */
  generateProgressiveTemplates(context) {
    return {
      full: this.generateIssueReport(context),
      medium: this._generateMediumTemplate(context),
      minimal: this.generateMinimalTemplate(context),
      titleOnly: this.generateIssueTitle(context)
    };
  }
  
  /**
   * Validate template content
   */
  validateTemplate(template) {
    if (!template || typeof template !== 'string') {
      return { isValid: false, reason: 'Template must be a non-empty string' };
    }
    
    if (template.length < 10) {
      return { isValid: false, reason: 'Template too short (minimum 10 characters)' };
    }
    
    if (template.length > 65000) {
      return { isValid: false, reason: 'Template too long (maximum 65000 characters)' };
    }
    
    // Check for required sections
    const requiredSections = ['Tool:', 'Error:'];
    for (const section of requiredSections) {
      if (!template.includes(section)) {
        return { 
          isValid: false, 
          reason: `Template missing required section: ${section}` 
        };
      }
    }
    
    return { isValid: true };
  }
  
  /**
   * Extract meaningful context summary
   */
  _extractSummaryFromContext(context) {
    const parts = [];
    
    if (context.failedTool) {
      parts.push(`Tool: ${context.failedTool}`);
    }
    
    if (context.errorMessage) {
      // Truncate long error messages
      const errorMsg = context.errorMessage.length > 100 
        ? `${context.errorMessage.substring(0, 100)}...`
        : context.errorMessage;
      parts.push(`Error: ${errorMsg}`);
    }
    
    if (context.command) {
      parts.push(`Command: ${context.command}`);
    }
    
    return parts.join(' | ');
  }
  
  /**
   * Generate medium-detail template
   */
  _generateMediumTemplate(context) {
    return `# QA System Issue Report

## Issue Details
- **Tool:** ${context.failedTool || 'unknown'}
- **Dimension:** ${context.toolDimension || 'general'}
- **Mode:** ${context.mode || 'automatic'}
- **Platform:** ${context.platform || process.platform}

## Error Information
${context.errorMessage || 'No error message provided'}

## Command Executed
\`\`\`bash
${context.command || 'unknown command'}
\`\`\`

## Environment
- QA Version: ${context.qaVersion || '0.1.0'}
- Timestamp: ${new Date().toISOString()}

*Auto-generated by QA System*`;
  }
  
  /**
   * Generate fallback template when TemplateManager fails
   */
  _generateFallbackTemplate(context) {
    this.logger.warn('FeedbackTemplateService: Using fallback template');
    return this._generateMediumTemplate(context);
  }
  
  /**
   * Get template statistics
   */
  getTemplateStats(template) {
    if (!template || typeof template !== 'string') {
      return { length: 0, lines: 0, words: 0 };
    }
    
    return {
      length: template.length,
      lines: template.split('\n').length,
      words: template.split(/\s+/).filter(word => word.length > 0).length,
      sections: (template.match(/^##?\s/gm) || []).length
    };
  }
}

module.exports = FeedbackTemplateService;